# üèóÔ∏è Gu√≠a de Desarrollo - Clean Architecture

## üìñ **√çNDICE**

1. [Arquitectura General](#arquitectura-general)
2. [Estructura de Carpetas](#estructura-de-carpetas)
3. [Patrones de Implementaci√≥n](#patrones-de-implementaci√≥n)
4. [Est√°ndares de C√≥digo](#est√°ndares-de-c√≥digo)
5. [Flujo de Desarrollo](#flujo-de-desarrollo)
6. [Testing](#testing)
7. [Seguridad](#seguridad)
8. [Logging y Monitoreo](#logging-y-monitoreo)
9. [Checklist de Implementaci√≥n](#checklist-de-implementaci√≥n)

---

## üèõÔ∏è **ARQUITECTURA GENERAL**

### **Principios Fundamentales**
- **Clean Architecture**: Separaci√≥n clara de responsabilidades
- **Dependency Inversion**: Las capas superiores no dependen de las inferiores
- **Single Responsibility**: Cada clase tiene una sola raz√≥n para cambiar
- **Open/Closed**: Abierto para extensi√≥n, cerrado para modificaci√≥n

### **Capas de la Arquitectura**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           PRESENTATION              ‚îÇ ‚Üê Controllers, Middleware
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ           APPLICATION               ‚îÇ ‚Üê Use Cases, Services, DTOs
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ             DOMAIN                  ‚îÇ ‚Üê Entities, Value Objects, Interfaces
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ          INFRASTRUCTURE             ‚îÇ ‚Üê Repositories, External Services
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üìÅ **ESTRUCTURA DE CARPETAS**

```
lib/
‚îú‚îÄ‚îÄ domain/                          # Capa de Dominio
‚îÇ   ‚îú‚îÄ‚îÄ entities/                    # Entidades de negocio
‚îÇ   ‚îú‚îÄ‚îÄ value-objects/               # Objetos de valor
‚îÇ   ‚îî‚îÄ‚îÄ interfaces/                  # Contratos/Interfaces
‚îú‚îÄ‚îÄ application/                     # Capa de Aplicaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ use-cases/                   # Casos de uso
‚îÇ   ‚îú‚îÄ‚îÄ services/                    # Servicios de aplicaci√≥n
‚îÇ   ‚îî‚îÄ‚îÄ dto/                         # Data Transfer Objects
‚îú‚îÄ‚îÄ infrastructure/                  # Capa de Infraestructura
‚îÇ   ‚îú‚îÄ‚îÄ repositories/                # Implementaciones de repositorios
‚îÇ   ‚îî‚îÄ‚îÄ container.ts                 # Inyecci√≥n de dependencias
‚îú‚îÄ‚îÄ presentation/                    # Capa de Presentaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ controllers/                 # Controladores HTTP
‚îÇ   ‚îî‚îÄ‚îÄ middleware/                  # Middleware personalizado
‚îú‚îÄ‚îÄ security/                        # Seguridad
‚îÇ   ‚îú‚îÄ‚îÄ sanitization.ts              # Sanitizaci√≥n de datos
‚îÇ   ‚îú‚îÄ‚îÄ csp.ts                       # Content Security Policy
‚îÇ   ‚îú‚îÄ‚îÄ file-validation.ts           # Validaci√≥n de archivos
‚îÇ   ‚îî‚îÄ‚îÄ react-escape.tsx             # Escape para React
‚îú‚îÄ‚îÄ validations/                     # Validaciones
‚îÇ   ‚îî‚îÄ‚îÄ [module].ts                  # Esquemas Zod por m√≥dulo
‚îú‚îÄ‚îÄ logging/                         # Logging y Monitoreo
‚îÇ   ‚îú‚îÄ‚îÄ logger.ts                    # Logger principal
‚îÇ   ‚îú‚îÄ‚îÄ edge-logger.ts               # Logger para Edge Runtime
‚îÇ   ‚îî‚îÄ‚îÄ alerts.ts                    # Sistema de alertas
‚îú‚îÄ‚îÄ auth/                            # Autenticaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ jwt-manager.ts               # Gesti√≥n de JWT
‚îÇ   ‚îú‚îÄ‚îÄ 2fa-manager.ts               # Autenticaci√≥n de dos factores
‚îÇ   ‚îú‚îÄ‚îÄ session-manager.ts           # Gesti√≥n de sesiones
‚îÇ   ‚îú‚îÄ‚îÄ oauth-manager.ts             # OAuth providers
‚îÇ   ‚îî‚îÄ‚îÄ password-policies.ts         # Pol√≠ticas de contrase√±as
‚îú‚îÄ‚îÄ rate-limit.ts                    # Rate limiting
‚îî‚îÄ‚îÄ hooks/                           # React Hooks
    ‚îú‚îÄ‚îÄ use-[module].ts              # Hooks por m√≥dulo
    ‚îî‚îÄ‚îÄ use-current-tenant.ts        # Hook de tenant actual

app/
‚îú‚îÄ‚îÄ api/                             # API Routes
‚îÇ   ‚îú‚îÄ‚îÄ [module]/                    # Endpoints por m√≥dulo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ route.ts                 # GET, POST principales
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [id]/                    # Endpoints por ID
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ route.ts             # GET, PUT, DELETE
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ [submodule]/         # Sub-recursos
‚îÇ   ‚îî‚îÄ‚îÄ [module]-v2/                 # Endpoints con nueva arquitectura
‚îú‚îÄ‚îÄ dashboard/                       # P√°ginas del dashboard
‚îÇ   ‚îú‚îÄ‚îÄ [module]/                    # P√°ginas por m√≥dulo
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx                 # P√°gina principal
‚îÇ   ‚îî‚îÄ‚îÄ layout.tsx                   # Layout del dashboard
‚îî‚îÄ‚îÄ [auth-pages]/                    # P√°ginas de autenticaci√≥n

components/
‚îú‚îÄ‚îÄ ui/                              # Componentes base (shadcn/ui)
‚îú‚îÄ‚îÄ [module]/                        # Componentes por m√≥dulo
‚îÇ   ‚îú‚îÄ‚îÄ [module]-list.tsx            # Lista de elementos
‚îÇ   ‚îú‚îÄ‚îÄ [module]-form.tsx            # Formulario
‚îÇ   ‚îî‚îÄ‚îÄ [module]-[action].tsx        # Acciones espec√≠ficas
‚îî‚îÄ‚îÄ layout/                          # Componentes de layout

scripts/                             # Scripts de base de datos
‚îú‚îÄ‚îÄ [NNN]_[description].sql          # Scripts SQL numerados
‚îî‚îÄ‚îÄ [description].js                 # Scripts de validaci√≥n/testing

__tests__/                           # Tests
‚îú‚îÄ‚îÄ integration/                     # Tests de integraci√≥n
‚îÇ   ‚îî‚îÄ‚îÄ api/                         # Tests de API
‚îî‚îÄ‚îÄ [module]/                        # Tests por m√≥dulo
```

---

## üîß **PATRONES DE IMPLEMENTACI√ìN**

### **1. Value Objects**

```typescript
// lib/domain/value-objects/[Entity]Id.ts
export class EntityId {
  private readonly value: string

  constructor(value: string) {
    if (!value || value.trim().length === 0) {
      throw new Error('EntityId cannot be empty')
    }
    
    // Validaci√≥n espec√≠fica (UUID, etc.)
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i
    if (!uuidRegex.test(value)) {
      throw new Error('EntityId must be a valid UUID')
    }
    
    this.value = value.trim()
  }

  getValue(): string {
    return this.value
  }

  equals(other: EntityId): boolean {
    return this.value === other.value
  }

  toString(): string {
    return this.value
  }

  static fromString(value: string): EntityId {
    return new EntityId(value)
  }

  static isValid(value: string): boolean {
    try {
      new EntityId(value)
      return true
    } catch {
      return false
    }
  }
}
```

### **2. Entities**

```typescript
// lib/domain/entities/[Entity].ts
import { EntityId } from '../value-objects/EntityId'

export class Entity {
  constructor(
    private readonly id: EntityId,
    private readonly name: string,
    private readonly tenantId: EntityId,
    private readonly isActive: boolean,
    private readonly createdAt: Date,
    private readonly updatedAt: Date
  ) {
    this.validate()
  }

  private validate(): void {
    if (!this.name || this.name.trim().length === 0) {
      throw new Error('Name cannot be empty')
    }
    
    if (this.name.length > 100) {
      throw new Error('Name cannot exceed 100 characters')
    }
  }

  // Getters
  getId(): EntityId { return this.id }
  getName(): string { return this.name }
  getTenantId(): EntityId { return this.tenantId }
  getIsActive(): boolean { return this.isActive }
  getCreatedAt(): Date { return this.createdAt }
  getUpdatedAt(): Date { return this.updatedAt }

  // M√©todos de negocio
  public activate(): Entity {
    if (this.isActive) return this
    
    return new Entity(
      this.id,
      this.name,
      this.tenantId,
      true,
      this.createdAt,
      new Date()
    )
  }

  public deactivate(): Entity {
    if (!this.isActive) return this
    
    return new Entity(
      this.id,
      this.name,
      this.tenantId,
      false,
      this.createdAt,
      new Date()
    )
  }

  // Serializaci√≥n
  public toPlainObject(): any {
    return {
      id: this.id.getValue(),
      name: this.name,
      tenantId: this.tenantId.getValue(),
      isActive: this.isActive,
      createdAt: this.createdAt.toISOString(),
      updatedAt: this.updatedAt.toISOString()
    }
  }

  public static fromPlainObject(data: any): Entity {
    return new Entity(
      EntityId.fromString(data.id),
      data.name,
      EntityId.fromString(data.tenantId),
      data.isActive,
      new Date(data.createdAt),
      new Date(data.updatedAt)
    )
  }
}
```

### **3. Repository Interfaces**

```typescript
// lib/domain/interfaces/[Entity]Repository.ts
import { Entity } from '../entities/Entity'
import { EntityId } from '../value-objects/EntityId'
import { TenantId } from '../value-objects/TenantId'

export interface EntityFilters {
  name?: string
  isActive?: boolean
  limit?: number
  offset?: number
}

export interface IEntityRepository {
  findById(id: EntityId, tenantId: TenantId): Promise<Entity | null>
  findByTenant(tenantId: TenantId, filters?: EntityFilters): Promise<Entity[]>
  findActiveByTenant(tenantId: TenantId): Promise<Entity[]>
  save(entity: Entity): Promise<Entity>
  delete(id: EntityId, tenantId: TenantId): Promise<void>
  exists(id: EntityId, tenantId: TenantId): Promise<boolean>
  countByTenant(tenantId: TenantId, filters?: EntityFilters): Promise<number>
  countActiveByTenant(tenantId: TenantId): Promise<number>
}
```

### **4. Repository Implementations**

```typescript
// lib/infrastructure/repositories/Supabase[Entity]Repository.ts
import { IEntityRepository, EntityFilters } from '../../domain/interfaces/EntityRepository'
import { Entity } from '../../domain/entities/Entity'
import { EntityId } from '../../domain/value-objects/EntityId'
import { TenantId } from '../../domain/value-objects/TenantId'
import { SupabaseClient } from '@supabase/supabase-js'

export class SupabaseEntityRepository implements IEntityRepository {
  constructor(private readonly supabase: SupabaseClient) {}

  async findById(id: EntityId, tenantId: TenantId): Promise<Entity | null> {
    const { data, error } = await this.supabase
      .from('entities')
      .select('*')
      .eq('id', id.getValue())
      .eq('tenant_id', tenantId.getValue())
      .single()

    if (error) {
      if (error.code === 'PGRST116') {
        return null // No rows returned
      }
      throw new Error(`Database error: ${error.message}`)
    }

    if (!data) {
      return null
    }

    return this.mapToEntity(data)
  }

  async findByTenant(tenantId: TenantId, filters?: EntityFilters): Promise<Entity[]> {
    let query = this.supabase
      .from('entities')
      .select('*')
      .eq('tenant_id', tenantId.getValue())

    // Aplicar filtros
    if (filters?.isActive !== undefined) {
      query = query.eq('is_active', filters.isActive)
    }

    if (filters?.name) {
      query = query.ilike('name', `%${filters.name}%`)
    }

    // Aplicar paginaci√≥n
    if (filters?.limit && filters?.offset !== undefined) {
      query = query.range(filters.offset, filters.offset + filters.limit - 1)
    }

    const { data, error } = await query
      .order('sort_order')
      .order('name')

    if (error) {
      throw new Error(`Database error: ${error.message}`)
    }

    if (!data) {
      return []
    }

    return data.map(this.mapToEntity)
  }

  async save(entity: Entity): Promise<Entity> {
    const entityData = this.mapToDatabase(entity)
    
    const { data, error } = await this.supabase
      .from('entities')
      .upsert(entityData)
      .select()
      .single()

    if (error) {
      throw new Error(`Database error: ${error.message}`)
    }

    return this.mapToEntity(data)
  }

  async delete(id: EntityId, tenantId: TenantId): Promise<void> {
    const { error } = await this.supabase
      .from('entities')
      .delete()
      .eq('id', id.getValue())
      .eq('tenant_id', tenantId.getValue())

    if (error) {
      throw new Error(`Database error: ${error.message}`)
    }
  }

  async exists(id: EntityId, tenantId: TenantId): Promise<boolean> {
    const { data, error } = await this.supabase
      .from('entities')
      .select('id')
      .eq('id', id.getValue())
      .eq('tenant_id', tenantId.getValue())
      .single()

    return !error && !!data
  }

  async countByTenant(tenantId: TenantId, filters?: EntityFilters): Promise<number> {
    let query = this.supabase
      .from('entities')
      .select('id', { count: 'exact', head: true })
      .eq('tenant_id', tenantId.getValue())

    if (filters?.isActive !== undefined) {
      query = query.eq('is_active', filters.isActive)
    }

    if (filters?.name) {
      query = query.ilike('name', `%${filters.name}%`)
    }

    const { count, error } = await query

    if (error) {
      throw new Error(`Database error: ${error.message}`)
    }

    return count || 0
  }

  async countActiveByTenant(tenantId: TenantId): Promise<number> {
    return this.countByTenant(tenantId, { isActive: true })
  }

  // M√©todos privados de mapeo
  private mapToEntity(data: any): Entity {
    return Entity.fromPlainObject({
      id: data.id,
      name: data.name,
      tenantId: data.tenant_id,
      isActive: data.is_active,
      createdAt: data.created_at,
      updatedAt: data.updated_at
    })
  }

  private mapToDatabase(entity: Entity): any {
    return {
      id: entity.getId().getValue(),
      name: entity.getName(),
      tenant_id: entity.getTenantId().getValue(),
      is_active: entity.getIsActive(),
      created_at: entity.getCreatedAt().toISOString(),
      updated_at: entity.getUpdatedAt().toISOString()
    }
  }
}
```

### **5. DTOs**

```typescript
// lib/application/dto/[Entity]Dto.ts
export interface EntityDto {
  id: string
  name: string
  tenantId: string
  isActive: boolean
  createdAt: string
  updatedAt: string
}

export interface CreateEntityDto {
  name: string
  description?: string
  isActive?: boolean
  sortOrder?: number
}

export interface UpdateEntityDto {
  name?: string
  description?: string
  isActive?: boolean
  sortOrder?: number
}

export interface EntityListDto {
  entities: EntityDto[]
  total: number
  page: number
  limit: number
  hasMore: boolean
}
```

### **6. Use Cases**

```typescript
// lib/application/use-cases/Get[Entities]UseCase.ts
import { IEntityRepository } from '../../domain/interfaces/EntityRepository'
import { IUserRepository } from '../../domain/interfaces/UserRepository'
import { EntityDto, EntityListDto } from '../dto/EntityDto'
import { EntityId } from '../../domain/value-objects/EntityId'
import { TenantId } from '../../domain/value-objects/TenantId'
import { UserId } from '../../domain/value-objects/UserId'

export interface GetEntitiesRequest {
  userId: string
  tenantId?: string
  filters?: {
    name?: string
    isActive?: boolean
    page?: number
    limit?: number
  }
}

export class GetEntitiesUseCase {
  constructor(
    private readonly entityRepository: IEntityRepository,
    private readonly userRepository: IUserRepository
  ) {}

  async execute(request: GetEntitiesRequest): Promise<EntityListDto> {
    // 1. Validar y convertir IDs
    const userId = UserId.fromString(request.userId)
    const tenantId = request.tenantId ? TenantId.fromString(request.tenantId) : null

    // 2. Obtener usuario
    const user = await this.userRepository.findById(userId)
    if (!user) {
      throw new Error('User not found')
    }

    // 3. Determinar tenant
    const finalTenantId = tenantId || user.getTenantId()
    if (!finalTenantId) {
      throw new Error('User does not have access to any tenant')
    }

    // 4. Validar acceso del usuario al tenant
    if (!user.getIsAdmin() && !user.belongsToTenant(finalTenantId)) {
      throw new Error('User does not have access to this tenant')
    }

    // 5. Preparar filtros
    const filters = {
      name: request.filters?.name,
      isActive: request.filters?.isActive,
      limit: request.filters?.limit || 50,
      offset: request.filters?.offset || 0
    }

    // 6. Obtener entidades
    const entities = await this.entityRepository.findByTenant(finalTenantId, filters)

    // 7. Obtener total para paginaci√≥n
    const total = await this.entityRepository.countByTenant(finalTenantId, filters)

    // 8. Retornar respuesta
    const page = Math.floor(filters.offset! / filters.limit!) + 1
    const hasMore = (filters.offset! + filters.limit!) < total
    
    return {
      entities: entities.map(this.mapToDto),
      total,
      page,
      limit: filters.limit!,
      hasMore
    }
  }

  private mapToDto(entity: Entity): EntityDto {
    return {
      id: entity.getId().getValue(),
      name: entity.getName(),
      tenantId: entity.getTenantId().getValue(),
      isActive: entity.getIsActive(),
      createdAt: entity.getCreatedAt().toISOString(),
      updatedAt: entity.getUpdatedAt().toISOString()
    }
  }
}
```

### **7. Controllers**

```typescript
// lib/presentation/controllers/[Entity]Controller.ts
import { NextRequest, NextResponse } from 'next/server'
import { GetEntitiesUseCase } from '../../application/use-cases/GetEntitiesUseCase'
import { CreateEntityUseCase } from '../../application/use-cases/CreateEntityUseCase'
import { EntityDto, CreateEntityDto } from '../../application/dto/EntityDto'

export class EntityController {
  constructor(
    private readonly getEntitiesUseCase: GetEntitiesUseCase,
    private readonly createEntityUseCase: CreateEntityUseCase
  ) {}

  async getEntities(request: NextRequest): Promise<NextResponse> {
    try {
      const userId = this.extractUserId(request)
      const tenantId = this.extractTenantId(request)
      const queryParams = this.extractQueryParams(request)

      const result = await this.getEntitiesUseCase.execute({
        userId,
        tenantId,
        filters: queryParams
      })

      return NextResponse.json({
        success: true,
        data: result
      })

    } catch (error) {
      return this.handleError(error)
    }
  }

  async createEntity(request: NextRequest): Promise<NextResponse> {
    try {
      const userId = this.extractUserId(request)
      const tenantId = this.extractTenantId(request)
      const body = this.extractBody(request)

      const result = await this.createEntityUseCase.execute({
        userId,
        tenantId,
        ...body
      })

      return NextResponse.json({
        success: true,
        data: this.mapToDto(result),
        message: 'Entity created successfully'
      }, { status: 201 })

    } catch (error) {
      return this.handleError(error)
    }
  }

  // M√©todos privados de extracci√≥n
  private extractUserId(request: NextRequest): string {
    const authHeader = request.headers.get('authorization')
    if (!authHeader) {
      throw new Error('Authorization header required')
    }
    // TODO: Implementar extracci√≥n real del JWT
    return 'user-id-placeholder'
  }

  private extractTenantId(request: NextRequest): string | undefined {
    return request.headers.get('x-tenant-id') || undefined
  }

  private extractQueryParams(request: NextRequest): any {
    const url = new URL(request.url)
    return {
      name: url.searchParams.get('name') || undefined,
      isActive: url.searchParams.get('is_active') === 'true' ? true : 
                url.searchParams.get('is_active') === 'false' ? false : undefined,
      page: parseInt(url.searchParams.get('page') || '1'),
      limit: parseInt(url.searchParams.get('limit') || '50')
    }
  }

  private extractBody(request: NextRequest): CreateEntityDto {
    // TODO: Implementar validaci√≥n con Zod
    return {} as CreateEntityDto
  }

  private mapToDto(entity: Entity): EntityDto {
    return {
      id: entity.getId().getValue(),
      name: entity.getName(),
      tenantId: entity.getTenantId().getValue(),
      isActive: entity.getIsActive(),
      createdAt: entity.getCreatedAt().toISOString(),
      updatedAt: entity.getUpdatedAt().toISOString()
    }
  }

  private handleError(error: any): NextResponse {
    console.error('[EntityController] Error:', error)

    // Mapear errores espec√≠ficos a c√≥digos HTTP
    if (error.message === 'Authorization header required') {
      return NextResponse.json({
        success: false,
        error: 'Unauthorized'
      }, { status: 401 })
    }

    if (error.message === 'User not found') {
      return NextResponse.json({
        success: false,
        error: 'User not found'
      }, { status: 404 })
    }

    if (error.message === 'User does not have access to this tenant') {
      return NextResponse.json({
        success: false,
        error: 'Access denied'
      }, { status: 403 })
    }

    // Error gen√©rico
    return NextResponse.json({
      success: false,
      error: 'Internal server error'
    }, { status: 500 })
  }
}
```

### **8. API Routes**

```typescript
// app/api/[module]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { EntityController } from '@/lib/presentation/controllers/EntityController'
import { GetEntitiesUseCase } from '@/lib/application/use-cases/GetEntitiesUseCase'
import { CreateEntityUseCase } from '@/lib/application/use-cases/CreateEntityUseCase'
import { getEntityRepository, getUserRepository } from '@/lib/infrastructure/container'

// Inyecci√≥n de dependencias
const entityRepository = getEntityRepository()
const userRepository = getUserRepository()

const getEntitiesUseCase = new GetEntitiesUseCase(entityRepository, userRepository)
const createEntityUseCase = new CreateEntityUseCase(entityRepository, userRepository)

const controller = new EntityController(getEntitiesUseCase, createEntityUseCase)

export async function GET(request: NextRequest) {
  return controller.getEntities(request)
}

export async function POST(request: NextRequest) {
  return controller.createEntity(request)
}
```

---

## üìù **EST√ÅNDARES DE C√ìDIGO**

### **1. Naming Conventions**
- **Clases**: PascalCase (`EntityController`, `GetEntitiesUseCase`)
- **Interfaces**: I + PascalCase (`IEntityRepository`)
- **M√©todos**: camelCase (`getEntities`, `createEntity`)
- **Variables**: camelCase (`entityId`, `tenantId`)
- **Constantes**: UPPER_SNAKE_CASE (`MAX_NAME_LENGTH`)
- **Archivos**: kebab-case (`entity-controller.ts`)

### **2. L√≠mites de Tama√±o**
- **M√©todos/Funciones**: M√°ximo 50 l√≠neas
- **Hooks personalizados**: M√°ximo 80 l√≠neas
- **Componentes React**: M√°ximo 150 l√≠neas
- **Archivos de utilidades**: M√°ximo 300 l√≠neas
- **Archivos de p√°gina/layout**: M√°ximo 400 l√≠neas

### **3. Imports**
```typescript
// 1. Librer√≠as externas
import { NextRequest, NextResponse } from 'next/server'
import { z } from 'zod'

// 2. Imports internos (ordenados alfab√©ticamente)
import { Entity } from '@/lib/domain/entities/Entity'
import { EntityId } from '@/lib/domain/value-objects/EntityId'
import { IEntityRepository } from '@/lib/domain/interfaces/EntityRepository'
```

### **4. Validaciones con Zod**
```typescript
// lib/validations/[module].ts
import { z } from "zod"
import { sanitizeText, isSafeString } from "@/lib/security/sanitization"

export const CreateEntitySchema = z.object({
  name: z.string()
    .min(1, "Nombre es requerido")
    .max(100, "Nombre no puede exceder 100 caracteres")
    .transform(sanitizeText)
    .refine(name => name.length > 0, "Nombre no puede estar vac√≠o despu√©s de sanitizaci√≥n")
    .refine(name => isSafeString(name), "Nombre contiene caracteres peligrosos"),
  
  description: z.string()
    .max(500, "Descripci√≥n no puede exceder 500 caracteres")
    .transform(sanitizeText)
    .refine(desc => !desc || isSafeString(desc), "Descripci√≥n contiene caracteres peligrosos")
    .optional(),
  
  isActive: z.boolean().default(true),
  sortOrder: z.number().int().min(0).max(999).default(0)
})
```

---

## üîÑ **FLUJO DE DESARROLLO**

### **Paso 1: An√°lisis de Requerimientos**
1. Identificar entidades de dominio
2. Definir casos de uso
3. Mapear relaciones entre entidades
4. Identificar validaciones necesarias

### **Paso 2: Implementaci√≥n de Dominio**
1. Crear Value Objects
2. Crear Entities
3. Definir Repository Interfaces
4. Implementar l√≥gica de negocio

### **Paso 3: Implementaci√≥n de Aplicaci√≥n**
1. Crear DTOs
2. Implementar Use Cases
3. Crear Services (si es necesario)

### **Paso 4: Implementaci√≥n de Infraestructura**
1. Implementar Repositories
2. Configurar Dependency Injection
3. Crear scripts de base de datos

### **Paso 5: Implementaci√≥n de Presentaci√≥n**
1. Crear Controllers
2. Implementar API Routes
3. Crear componentes React
4. Implementar hooks

### **Paso 6: Testing**
1. Tests de Value Objects
2. Tests de Entities
3. Tests de Use Cases
4. Tests de Controllers
5. Tests de integraci√≥n

### **Paso 7: Seguridad**
1. Validaciones con Zod
2. Sanitizaci√≥n de datos
3. Rate limiting
4. Logging de seguridad

---

## üß™ **TESTING**

### **Estructura de Tests**
```
__tests__/
‚îú‚îÄ‚îÄ integration/
‚îÇ   ‚îî‚îÄ‚îÄ api/
‚îÇ       ‚îî‚îÄ‚îÄ [module].test.ts
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entities/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [Entity].test.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ value-objects/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ [Entity]Id.test.ts
‚îÇ   ‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ use-cases/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ [UseCase].test.ts
‚îÇ   ‚îî‚îÄ‚îÄ presentation/
‚îÇ       ‚îî‚îÄ‚îÄ controllers/
‚îÇ           ‚îî‚îÄ‚îÄ [Controller].test.ts
```

### **Patr√≥n de Test**
```typescript
// __tests__/lib/domain/entities/Entity.test.ts
import { Entity } from '@/lib/domain/entities/Entity'
import { EntityId } from '@/lib/domain/value-objects/EntityId'
import { TenantId } from '@/lib/domain/value-objects/TenantId'

describe('Entity', () => {
  let validEntityId: EntityId
  let validTenantId: TenantId
  let now: Date

  beforeEach(() => {
    validEntityId = EntityId.fromString('123e4567-e89b-12d3-a456-426614174000')
    validTenantId = TenantId.fromString('123e4567-e89b-12d3-a456-426614174001')
    now = new Date()
  })

  describe('constructor', () => {
    it('should create a valid Entity', () => {
      const entity = new Entity(
        validEntityId,
        'Test Entity',
        validTenantId,
        true,
        now,
        now
      )

      expect(entity.getId()).toBe(validEntityId)
      expect(entity.getName()).toBe('Test Entity')
      expect(entity.getIsActive()).toBe(true)
    })

    it('should throw error for empty name', () => {
      expect(() => new Entity(
        validEntityId,
        '',
        validTenantId,
        true,
        now,
        now
      )).toThrow('Name cannot be empty')
    })
  })

  describe('activate', () => {
    it('should activate an inactive entity', () => {
      const entity = new Entity(
        validEntityId,
        'Test Entity',
        validTenantId,
        false,
        now,
        now
      )

      const activatedEntity = entity.activate()

      expect(activatedEntity.getIsActive()).toBe(true)
      expect(activatedEntity.getId()).toBe(validEntityId)
    })
  })
})
```

---

## üîí **SEGURIDAD**

### **1. Validaciones Obligatorias**
- **Zod schemas** para todos los inputs
- **Sanitizaci√≥n** de todos los strings
- **Validaci√≥n de tipos** estricta
- **Rate limiting** en todos los endpoints

### **2. Headers de Seguridad**
```typescript
// Aplicados autom√°ticamente por middleware
- Content-Security-Policy
- X-Frame-Options: DENY
- X-Content-Type-Options: nosniff
- X-XSS-Protection: 1; mode=block
- Referrer-Policy: strict-origin-when-cross-origin
```

### **3. Logging de Seguridad**
```typescript
// Eventos que se deben loguear
- rateLimitExceeded
- xssAttempt
- sqlInjectionAttempt
- failedLogin
- successfulLogin
- unauthorizedAccess
- resourceCreated
- resourceUpdated
- resourceDeleted
```

---

## üìä **LOGGING Y MONITOREO**

### **1. Tipos de Logs**
- **General**: Operaciones normales
- **Security**: Eventos de seguridad
- **Error**: Errores y excepciones
- **Audit**: Cambios importantes

### **2. Estructura de Logs**
```typescript
{
  timestamp: '2025-01-07T10:30:00.000Z',
  level: 'info',
  event: 'resourceCreated',
  userId: 'user-123',
  resourceType: 'configuration',
  resourceId: 'config-456',
  details: {
    name: 'Test Configuration',
    tenantId: 'tenant-789'
  },
  metadata: {
    ip: '192.168.1.1',
    userAgent: 'Mozilla/5.0...',
    endpoint: '/api/configurations'
  }
}
```

---

## ‚úÖ **CHECKLIST DE IMPLEMENTACI√ìN**

### **Para Nueva Funcionalidad:**

#### **üìã Fase 1: An√°lisis**
- [ ] Definir entidades de dominio
- [ ] Identificar casos de uso
- [ ] Mapear relaciones
- [ ] Definir validaciones

#### **üìã Fase 2: Dominio**
- [ ] Crear Value Objects
- [ ] Crear Entities
- [ ] Definir Repository Interfaces
- [ ] Implementar l√≥gica de negocio

#### **üìã Fase 3: Aplicaci√≥n**
- [ ] Crear DTOs
- [ ] Implementar Use Cases
- [ ] Crear Services (si necesario)

#### **üìã Fase 4: Infraestructura**
- [ ] Implementar Repositories
- [ ] Configurar Dependency Injection
- [ ] Crear scripts SQL

#### **üìã Fase 5: Presentaci√≥n**
- [ ] Crear Controllers
- [ ] Implementar API Routes
- [ ] Crear componentes React
- [ ] Implementar hooks

#### **üìã Fase 6: Testing**
- [ ] Tests de Value Objects
- [ ] Tests de Entities
- [ ] Tests de Use Cases
- [ ] Tests de Controllers
- [ ] Tests de integraci√≥n

#### **üìã Fase 7: Seguridad**
- [ ] Validaciones Zod
- [ ] Sanitizaci√≥n
- [ ] Rate limiting
- [ ] Logging de seguridad

#### **üìã Fase 8: Validaci√≥n**
- [ ] Build exitoso
- [ ] Tests pasando
- [ ] Funcionalidad probada
- [ ] Documentaci√≥n actualizada

---

## üöÄ **COMANDOS √öTILES**

### **Desarrollo**
```bash
# Iniciar servidor de desarrollo
npm run dev

# Build de producci√≥n
npm run build

# Ejecutar tests
npm test

# Tests con cobertura
npm run test:coverage

# Tests en modo watch
npm run test:watch
```

### **Base de Datos**
```bash
# Ejecutar script de validaci√≥n
node scripts/validate_[module].js

# Ejecutar script SQL
psql -h [HOST] -U [USER] -d [DATABASE] -f scripts/[NNN]_[description].sql
```

---

## üìö **REFERENCIAS**

### **Archivos de Referencia**
- `REFACTORING_ANALYSIS.md` - An√°lisis completo de la arquitectura
- `TESTING_GUIDE.md` - Gu√≠a detallada de testing
- `FASE5_ARQUITECTURA_PLAN.md` - Plan de implementaci√≥n de Clean Architecture

### **Patrones Implementados**
- **Clean Architecture** - Separaci√≥n de capas
- **Repository Pattern** - Abstracci√≥n de datos
- **Use Case Pattern** - L√≥gica de aplicaci√≥n
- **DTO Pattern** - Transferencia de datos
- **Dependency Injection** - Gesti√≥n de dependencias

---

## üéØ **PR√ìXIMOS PASOS**

Cuando solicites una nueva funcionalidad, seguir√© este flujo:

1. **An√°lisis** - Identificar entidades y casos de uso
2. **Implementaci√≥n** - Seguir el patr√≥n establecido
3. **Testing** - Crear tests completos
4. **Validaci√≥n** - Verificar que todo funciona
5. **Documentaci√≥n** - Actualizar esta gu√≠a si es necesario

**¬°Esta gu√≠a asegura consistencia y calidad en todas las futuras implementaciones!** üéâ
